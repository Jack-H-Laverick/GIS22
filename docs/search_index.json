[["index.html", "An Introduction to Making Maps with R Introduction", " An Introduction to Making Maps with R Dr Jack H. Laverick, University of Strathclyde 13 - January - 2022 Introduction Welcome! This document provides a brief introduction to maps and how to think about creating them in the R programming language. It supports an online workshop, but won’t be here forever, so you may want to make your own notes and copy the code as we go. You do not need to know how to code for this workshop, but it is assumed that you can. If you feel like trying to code afterwards and get into trouble then you can send questions to jack.laverick@strath.ac.uk. To use this document, you can click on the table of contents to the left to jump to sections. You’ll notice buttons dotted around the document labelled Code. Clicking on these will reveal the code used to create example maps. We have a few learning objectives for today. By the end of the workshop attendees will have seen: The benefits of creating maps using a programming language. Examples of different maps generated in R. How to combine multiple datasets into a single map. "],["data-types-for-maps.html", "1 Data Types For Maps 1.1 Rasters 1.2 Points 1.3 Lines 1.4 Polygons", " 1 Data Types For Maps Examples of different maps generated in R. When it comes to building a map, just like any other figure, there are multiple ways to display your data. You’ll be able to go a long way towards recreating something you like the look of if you can break it down into its constituent parts. The best way to display your data on a map will vary depending on what you want to show, and whether you want to combine multiple datasets by layering up map elements. There are two main flavours of data for maps, vectors and rasters (above, left and right). If you know anything about digital image formats you might be familiar with this. Vectors are join the dot exercises, this means they don’t become pixelated when you change the image size, and they can take up less memory than a high resolution raster because you just need to store the rules for connecting points. Rasters are a grid of cells and are very powerful tools useful for visualising regularly arranged data. They are specialised for this use case though, so might not be the best way to show every dataset you come across. 1.1 Rasters Rasters are a regular arrangement of cells which cover an area. They are useful when you have continuous data which changes across an area. Think sea surface temperature or depth. You wouldn’t want to define a polygon for every box and fill them with a unique colour! Rasters excel at doing this particular job. Rasters can be saved in many formats, this can be as simple as a csv file of regularly spaced X and Y coordinates. The example below imports a raster layer of distance from shore directly from an online database. library(sdmpredictors) # Load functions distance_to_shore &lt;- load_layers(&quot;MS_biogeo05_dist_shore_5m&quot;) # Import raster ne_atlantic_ext &lt;- extent(-100, 45, 30.75, 72.5) # Define a cropping window distance_to_shore_crop &lt;- crop(distance_to_shore, ne_atlantic_ext) # Crop raster to fit the North Atlantic my_colors &lt;- colorRampPalette(c(&quot;#5E85B8&quot;,&quot;#EDF0C0&quot;,&quot;#C13127&quot;)) # Get a colour ramp plot(distance_to_shore_crop, col = my_colors(1000), axes=FALSE, box=FALSE) # Plot the raster title(cex.sub = 1.25, sub = &quot;Distance from shore (km)&quot;, # Add labels line = -1.5) 1.2 Points Points are useful for indicating specific locations. Think sampling locations and other points of interest. The example below plots the locations of life boat stations around the UK and Ireland, importing from a csv file. You can download the data for yourself here. If your data consists of lots of points and is regularly arranged have a look at the section on rasters. RNLI &lt;- read.csv(&quot;./Data/RNLI.csv&quot;) # Import data from a csv file ggplot(RNLI) + # Use the data to start a plot geom_point(aes(X, Y, fill = Region), colour = &quot;black&quot;, shape = 21) + # Make a super simple &quot;map&quot; using points theme_minimal() + # Change appearance to a template coord_equal() + # Set the aspect ratio labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;Lifebat stations around the UK and Ireland&quot;) 1.3 Lines Lines are produced by connecting points, they are useful for showing boundaries or tracks. Think coastlines and animal tracks. The example below plots the tracks of anonymised boats around the UK, importing from a shapefile. You can download the data for yourself here. Boats &lt;- sf::st_read(&quot;./Data/Anonymised_AIS_Derived_Track_Lines_2015_MMO/&quot;, quiet = TRUE) %&gt;% # Import data from a shapefile arrange(Shape_Leng) # Order the data so long journeys are plotted on top of short journeys ## There&#39;s a lot of data in the shape file, if this stresses out your computer try filtering out some of the boat tracks using an SQL query. Example below. #Boats &lt;- sf::st_read(&quot;./Data/Anonymised_AIS_Derived_Track_Lines_2015_MMO/&quot;, quiet = TRUE, # Import data from a shapefile # query = &quot;SELECT Shape_Leng FROM Anonymised_AIS_Derived_Track_Lines_2015_MMO WHERE Shape_Leng &gt; 10000&quot;) %&gt;% # You can import a subset of the data using an SQL query. # arrange(Shape_Leng) # Order the data so long journeys are ggplot(Boats) + # Start the plot geom_sf(aes(colour = Shape_Leng), size = 0.05) + # Plot the lines in the shape file scale_colour_gradient(low = &quot;#132B43&quot;, high = &quot;#e6c41e&quot;) + # Set a colour scale theme_minimal() + # Use an appearance template labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;MMO tracked boat journeys&quot;, colour = &quot;Distance (m)&quot;) 1.4 Polygons Polygons are produced by enclosing lines. This allows you to fill an area. This can be useful for indicating marine protected areas or land masses. The example below plots ICES fishing areas in the north Atlantic, importing from a shape file. You can get the data here. ICES &lt;- sf::st_read(&quot;./Data/ICES_areas/&quot;, quiet = TRUE) %&gt;% # Import the polygons from a shapefile filter(SUBOCEAN == 2) %&gt;% # Limit to north Atlantic drop_na(F_SUBAREA) # Drop polygons labelled NA ggplot(ICES) + # Start a plot geom_sf(aes(fill = F_SUBAREA), size = 0.5, colour = &quot;white&quot;) + # Add the polygons theme_minimal() + # Use an appearance template labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;ICES fishing areas&quot;, fill = NULL) "],["layering-multiple-datasets.html", "2 Layering Multiple Datasets", " 2 Layering Multiple Datasets How to combine multiple datasets into a single map. So you’ve now seen some very basic maps created in R, but what if you want to show multiple items on one image? Luckily as long as your data objects are based on the same coordinate system, you can simply add an extra line of code. Both the vessel tracks dataset and ICES management areas are currently in sf format. Remember, this behaves the same as any other ggplot, so the layers are plotted in the order they are specified in the code. Decide which shapes you want on top! Boats &lt;- sf::st_read(&quot;./Data/Anonymised_AIS_Derived_Track_Lines_2015_MMO/&quot;, quiet = TRUE, # Import data from a shapefile query = &quot;SELECT Shape_Leng FROM Anonymised_AIS_Derived_Track_Lines_2015_MMO WHERE Shape_Leng &gt; 10000&quot;) %&gt;% # You can import a subset of the data using an SQL query. arrange(Shape_Leng) # Order the data so long journeys are ICES &lt;- sf::st_read(&quot;./Data/ICES_areas/&quot;, quiet = TRUE) %&gt;% # Import the polygons from a shapefile filter(SUBOCEAN == 2) %&gt;% # Limit to north Atlantic drop_na(F_SUBAREA) # Drop polygons labelled NA ggplot() + # Start the plot geom_sf(data = ICES, fill = &quot;black&quot;, size = 0.5, colour = &quot;white&quot;) + # Add the polygons geom_sf(data = Boats, aes(colour = Shape_Leng), size = 0.05) + # Plot the lines scale_colour_gradient(low = &quot;#132B43&quot;, high = &quot;#e6c41e&quot;) + # Set a colour scale theme_minimal() + # Use an appearance template theme(legend.position = &quot;top&quot;) + labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;MMO tracked boat journeys, over ICES areas&quot;, colour = &quot;Distance (m)&quot;) + coord_sf(xlim = c(-20, 10), ylim = c(45, 65), expand = FALSE) For the second example we’re going to combine a raster and point data. ggplot has a geom_raster() but like all ggplot geometries it expects a dataframe. The trick is to convert the raster object to a dataframe. After that, as both the RNLI data and the distance from shore data use lat/lon coordinates we can put them on the same plot. library(sdmpredictors) # Load functions distance_to_shore &lt;- load_layers(&quot;MS_biogeo05_dist_shore_5m&quot;) # Import raster ne_atlantic_ext &lt;- extent(-80, 45, 30.75, 72.5) # Define a cropping window distance_to_shore_crop &lt;- crop(distance_to_shore, ne_atlantic_ext) %&gt;% # Crop raster to fit the North Atlantic as.data.frame(xy = T) RNLI &lt;- read.csv(&quot;./Data/RNLI.csv&quot;) # Import data from a csv file ggplot() + geom_raster(data = distance_to_shore_crop, aes(x=x, y=y, fill = MS_biogeo05_dist_shore_5m)) + # Plot ratser geom_point(data = RNLI, aes(X, Y), colour = &quot;white&quot;, size = 0.4) + # Add lifeboat stations theme_minimal() + # Change appearance to a template theme(legend.position = &quot;top&quot;) + coord_equal(xlim = c(-20, 10), ylim = c(45, 65), expand = FALSE) + # Set the aspect ratio and zoom in labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;Lifebat stations around the UK and Ireland, with distance to shore.&quot;, fill = &quot;Shore distance (Km)&quot;) But what if we want to combine sf objects with rasters? There’s a package for raster data to connect with the sf philosophy called stars. The approach is the same as last time, but instead of converting to a dataframe we convert to an stars object. library(sdmpredictors) # Load functions library(stars) distance_to_shore &lt;- load_layers(&quot;MS_biogeo05_dist_shore_5m&quot;) # Import raster ne_atlantic_ext &lt;- extent(-80, 45, 30.75, 72.5) # Define a cropping window distance_to_shore_crop &lt;- crop(distance_to_shore, ne_atlantic_ext) %&gt;% # Crop raster to fit the North Atlantic st_as_stars() # Convert to a stars object Boats &lt;- sf::st_read(&quot;./Data/Anonymised_AIS_Derived_Track_Lines_2015_MMO/&quot;, quiet = TRUE, # Import data from a shapefile query = &quot;SELECT Shape_Leng FROM Anonymised_AIS_Derived_Track_Lines_2015_MMO WHERE Shape_Leng &gt; 10000&quot;) %&gt;% # You can import a subset of the data using an SQL query. arrange(Shape_Leng) # Order the data so long journeys are ICES &lt;- sf::st_read(&quot;./Data/ICES_areas/&quot;, quiet = TRUE) %&gt;% # Import the polygons from a shapefile filter(SUBOCEAN == 2) %&gt;% # Limit to north Atlantic drop_na(F_SUBAREA) # Drop polygons labelled NA ggplot() + # Start the plot geom_stars(data = distance_to_shore_crop) + # Add the stars object geom_sf(data = ICES, fill = NA, size = 0.1, colour = &quot;white&quot;) + # Add the polygons geom_sf(data = Boats, aes(colour = Shape_Leng), size = 0.05) + # Plot the lines scale_colour_gradient(low = &quot;#132B43&quot;, high = &quot;#e6c41e&quot;) + # Set a colour scale theme_minimal() + # Use an appearance template theme(legend.position = &quot;top&quot;) + labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;MMO tracked boat journeys, over ICES areas and shore distance&quot;, colour = &quot;Distance (m)&quot;, fill = &quot;Shore distance (Km)&quot;) + coord_sf(xlim = c(-20, 10), ylim = c(45, 65), expand = FALSE) # Zoom in on the map "],["why-would-we-think-about-using-r.html", "3 Why Would We Think About Using R? 3.1 Open source 3.2 Reproducibility 3.3 Geocomputation", " 3 Why Would We Think About Using R? The benefits of creating maps using a programming language. It’s true there are many programmes out there which let you build maps. These can be everything from image editors like Photoshop, to proprietary GIS software like ARCGIS. Using a programming language offers a number of advantages in some situations. 3.1 Open source This is the main benefit. R is Free, when you leave your institution you will still be able to use it without a license. The language is also ever expanding, and there is tonnes of help online which you don’t just get in a manual. Look on Twitter for #Rspatial. Whenever someone writes code that has wider use, it’s likely they will write it into a package. Below I’ve listed some really helpful ones you may want to look into for making maps and using spatial data. raster terra sf stars rayshader 3.2 Reproducibility Code is key to reproducible (and repeatable science). It’s hard to document which button you clicked on, but code is always there to come back to. This also means if you ever want to tweak something you can just change one line in the code, instead of having to manually change elements. It also means once you’ve figured out a task once, it’s very fast to do the same thing again for different locations. 3.3 Geocomputation Unlike in an image editor, you can perform further calculations. Your data may be of a different type to the data visualistion you had in mind. This might be a problem if you were creating your map in photoshop or cough powerpoint, but with R you can perform a variety of spatial calculations to create new objects to plot. You can either cast the data into a new type, point ⇢ line ⇢ polygon, or summarise your data into a new object for mapping, perhaps a raster. I’ve given a few examples of what’s possible below, but Google is your friend (and stack overflow) for finding new and exciting options. 3.3.0.1 Contours rasters ⇢ lines or polygons You may have a raster containing a lot of information, but want to combine the information with other data layers. To avoid things getting too busy you can reduce the raster to contour lines. These show the boundaries for areas contained within a particular value. Think of contour lines for elevation on an ordinance survey map. The example below gets contour lines from the distance to shore data. # Contour example raster library(sdmpredictors) # Load functions distance_to_shore &lt;- load_layers(&quot;MS_biogeo05_dist_shore_5m&quot;) %&gt;% # Import raster subset(1) # This is just some data cleaning ne_atlantic_ext &lt;- extent(-100, 45, 30.75, 72.5) # Define a cropping window distance_to_shore_crop &lt;- crop(distance_to_shore, ne_atlantic_ext) # Crop raster to fit the North Atlantic contour &lt;- rasterToContour(distance_to_shore_crop) # Calculate contours my_colors = colorRampPalette(c(&quot;#5E85B8&quot;,&quot;#EDF0C0&quot;,&quot;#C13127&quot;)) # Get a colour ramp plot(distance_to_shore_crop, col = my_colors(1000), axes=FALSE, box=FALSE) # Plot the raster plot(contour, add = TRUE) # Add contour lines title(cex.sub = 1.25, sub = &quot;Distance from shore (km), with contours&quot;, # Add labels line = -1.5) 3.3.0.2 Density maps points ⇢ lines or polygons You can think of density maps as being closely related to contour plots. Really what you are doing is creating contours (filled = polygons, not filed = lines) of a density field. The density field will be a raster which has been computed from point data. So you can see how to get to a density map you need to move from points through multiple data types to get to the visualisation you’re after. The example below calculates the density of lifeboat stations. RNLI &lt;- read.csv(&quot;./Data/RNLI.csv&quot;) # Import the lifeboat station positions ggplot(RNLI, aes(X, Y)) + # Start the plot, specifying x and y column geom_density2d_filled() + # Add a filled density field geom_point(colour = &quot;black&quot;, fill = &quot;white&quot;, shape = 21) + # Add the points on top theme_minimal() + # Use and aesthetic template coord_equal() + # Set the aspect ratio labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add labels fill = &quot;Density&quot;, caption = &quot;Lifebat stations around the UK and Ireland&quot;) The next code chunk creates the same figure, but uses a slightly different syntax to play nicely with SF objects. The main advantage is that you can easily change map projections and the density field is measured in “real space.” See the section on map projections for more details. RNLI &lt;- read.csv(&quot;./Data/RNLI.csv&quot;) %&gt;% # Import the points again sf::st_as_sf(coords = c(&quot;X&quot;, &quot;Y&quot;), crs = 4326) %&gt;% # Convert to sf points using the x and y column as coordinates sf::st_transform(crs = 3035) # Use a different map projection ggplot(RNLI) + # Start the plot stat_density_2d_filled(mapping = ggplot2::aes(x = purrr::map_dbl(geometry, ~.[1]), # Calculate density from the sf object y = purrr::map_dbl(geometry, ~.[2]))) + geom_sf(fill = &quot;white&quot;, colour = &quot;black&quot;, shape = 21) + # Add the points on top theme_minimal() + # Use an aesthetic template labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add labels fill = &quot;Density&quot;, caption = &quot;Lifebat stations around the UK and Ireland&quot;) 3.3.0.3 Point in polygon analysis polygons ⇢ to points There may be times when you want to join polygon attributes (fishing area or habitat types) to points or grid cells (animal tracker pings or climate predictions). The way to do this is to perform a spatial join. In the example below I’m showing the ICES fishing areas a boat passes through. To do this we sample the polygons at points along the longest boat journey from the shipping dataset. ICES &lt;- sf::st_read(&quot;./Data/ICES_areas/&quot;, quiet = TRUE) %&gt;% # Import the polygons from a shapefile filter(SUBOCEAN == 2) %&gt;% # Limit to north Atlantic drop_na(F_SUBAREA) # Drop polygons labelled NA Boats &lt;- sf::st_read(&quot;./Data/Anonymised_AIS_Derived_Track_Lines_2015_MMO/&quot;, quiet = TRUE, # Import data from a shapefile query = &quot;SELECT Shape_Leng FROM Anonymised_AIS_Derived_Track_Lines_2015_MMO WHERE Shape_Leng &gt; 1000000&quot;) %&gt;% # You can import a subset of the data using an SQL query. filter(Shape_Leng == max(Shape_Leng)) %&gt;% # Keep only the longest ship journey sf::st_cast(&quot;POINT&quot;) %&gt;% # Convert the line to points sf::st_transform(crs = sf::st_crs(ICES)) %&gt;% # Make sure the map projections match sf::st_join(ICES) # Ask which polygons points fall in ICES &lt;- filter(ICES, F_CODE %in% Boats$F_CODE) # Drop ICES areas the ship didn&#39;t go through ggplot() + # Start the plot geom_sf(data = ICES, fill = &quot;grey&quot;, colour = &quot;white&quot;) + # Mark the ICES areas geom_sf(data = Boats, aes(colour = F_CODE)) + # Colour points by ICES area theme_minimal() + # Use an appearance template labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;MMO tracked boat journeys&quot;, colour = &quot;ICES area&quot;) 3.3.0.4 Polygonising raster ⇢ polygons If you have a qualitative raster (say of 5 habitat types) you may want to merge identical cells into a single shape. This also opens the door to point in polygon analysis like above. There are also functions which let you sample points from a raster directly, but you won’t have the polygon for other uses. For the example below I’ve rounded the distance to shore dataset to the nearest 1000 km. This gives us three bands of distance we can condense into three shapes. I’ve made the boundaries for the polygons white to “prove” to you that the cells have merged into a single polygon. library(stars) distance &lt;- round(distance_to_shore_crop, -3) %&gt;% # Round distance to shore to the nearest 1000km st_as_stars() %&gt;% # convert to stars object (intermediate step) st_as_sf(merge = TRUE, as_points = FALSE) # Merge cells with the same value to an sf polygon ggplot(distance) + # Start the plot geom_sf(aes(fill = layer), colour = &quot;white&quot;) + # Add the polygons theme_minimal() + # Use an aesthetic template labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add labels fill = &quot;Distance&quot;, caption = &quot;Distance from shore (nearest 1000 km)&quot;) 3.3.0.5 And much more You can find a whole list of geocomputation functions documented online here. "],["map-projections.html", "4 Map Projections 4.1 Why do map projections matter? 4.2 Mercator 4.3 High-latitude 4.4 Arctic-centred", " 4 Map Projections Examples of different maps generated in R. The benefits of creating maps using a programming language. Any time you look at a 2D map you are looking at a map projection which contorts a 3D surface to fit on a page (sorry flat earthers). The Hereford Mappa Mundi (above) looks nonsensical at first, but that’s only because you don’t immediately understand the rules defining the map projection. There are many different ways to project the globe, all with pros and cons. 4.1 Why do map projections matter? The units of a map projection are not constant in terms or real world distance (see above). This can affect any geocomputation you do, such as looking for nearest neighbours. Map projections can also seriously affect how you view spatial relationships, and can have a significant impact on your story telling. The Spilhaus map projection (below) is an extreme case which reimagines the world as a single ocean. I’ve included code below to reproject a world map to a few example map projections. These projections are defined as coordinate reference systems (crs) with common ones accessible as epsg codes. I’ve focussed on varying latitude in the examples, but you might want to think about other factors for your studies, such as whether to centre on the Pacfic, or other longitudes. You can play around with other map projections by searching on google for epsg codes supported by R. 4.2 Mercator land &lt;- rnaturalearth::ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) # Import a world map ggplot(land) + # Start a plot geom_sf() + # Add the polygons theme_void() + # use an aesthetic template labs(caption = str_glue(&quot;EPSG code: {sf::st_crs(land)$epsg}&quot;)) # Add a label for the projection 4.3 High-latitude land &lt;- rnaturalearth::ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) %&gt;% # Import a world map sf::st_transform(crs = 3035) # Transform the polygons to a new projection ggplot(land) + geom_sf() + theme_void() + labs(caption = str_glue(&quot;EPSG code: {sf::st_crs(land)$epsg}&quot;)) 4.4 Arctic-centred land &lt;- rnaturalearth::ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) %&gt;% sf::st_transform(crs = 3575) # Transform to a third crs ggplot(land) + geom_sf() + theme_void() + labs(caption = str_glue(&quot;EPSG code: {sf::st_crs(land)$epsg}&quot;)) "],["animatingbatching-maps.html", "5 Animating/Batching Maps", " 5 Animating/Batching Maps The benefits of creating maps using a programming language. Some people expressed an interest in making animated maps. This is where doing things programmatically starts to shine. All you have to do is iterate and save a different map for each frame in your animation, then stitch them together in order using a gif maker like gifski. Though the code below turns multiple images into an animation, you can use the same principle with the map() function to programmatically produce multiple separate maps. This could be The same map but for different species, or zoomed in to different locations in the world. RNLI &lt;- read.csv(&quot;./Data/RNLI.csv&quot;) # Import data from a csv file map(1:nrow(RNLI), ~{ RNLI_frame &lt;- slice(RNLI, 1:.x) # Get a subset of data to plot ggplot(RNLI_frame) + # Use the data to start a plot geom_point(aes(X, Y, fill = Region), colour = &quot;black&quot;, shape = 21) + # Make a super simple &quot;map&quot; using points theme_minimal() + # Change appearance to a template coord_equal() + # Set the aspect ratio labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;Lifebat stations around the UK and Ireland&quot;) ggsave(str_glue(&quot;./Figures/RNLI{.x}.png&quot;)) # Save the frame with a unique file name print(str_glue(&quot;{.x}/{nrow(RNLI)}&quot;)) }) # Now stitch the frames into a gif library(gifski) gifski(str_glue(&quot;./Figures/RNLI{1:nrow(RNLI)}.png&quot;), gif_file = &quot;./Figures/animation.gif&quot;, width = 800, height = 600, delay = 0.1, loop = 1) "],["extra-tools.html", "6 Extra Tools 6.1 Insets 6.2 Backgrounds 6.3 3D", " 6 Extra Tools As a final bonus I’ve included a few examples of other things which can help you in your map making with R. These didn’t really fit anywhere else, but are tricks I use all the time! 6.1 Insets It can be really helpful to have a smaller plot on top of a bigger plot (an inset window). You can do this with any kind of plot, but it’s particularly useful for maps, as it allows you to show zoomed in views, or positions relative to larger landmasses. The general workflow is to make two plots before combining them ## Create a map of the world with a point marked on it land &lt;- rnaturalearth::ne_countries(scale = &quot;medium&quot;, returnclass = &quot;sf&quot;) %&gt;% # Import a world map sf::st_transform(crs = 3035) # Transform the polygons to a new projection point &lt;- data.frame(x = 0, y = 60) %&gt;% # Set your coordiantes sf::st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;), crs = 4326) %&gt;% # Convert to SF object sf::st_transform(crs = 3035) # Transform to a new crs World_map &lt;- ggplot() + # Start the plot geom_sf(data = land, fill = &quot;white&quot;, colour = &quot;white&quot;, size = 0.1) + # Add the land polygons geom_sf(data = point, colour = &quot;orange&quot;) + # Add a marked point theme_void() # Use an aesthetic template ## Create the zoomed in map for RNLI stations RNLI &lt;- read.csv(&quot;./Data/RNLI.csv&quot;) %&gt;% # Import the points again sf::st_as_sf(coords = c(&quot;X&quot;, &quot;Y&quot;), crs = 4326) # Convert to sf points using the x and y column as coordinates RNLI_map &lt;- ggplot(RNLI) + # Start the plot stat_density_2d_filled(mapping = ggplot2::aes(x = purrr::map_dbl(geometry, ~.[1]), # Calculate density from the sf object y = purrr::map_dbl(geometry, ~.[2]))) + geom_sf(fill = &quot;white&quot;, colour = &quot;black&quot;, shape = 21) + # Add the points on top theme_minimal() + # Use an aesthetic template labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add labels fill = &quot;Density&quot;, caption = &quot;Lifebat stations around the UK and Ireland&quot;) ## Combine the two plots RNLI_map + # Start with the biggest map annotation_custom(ggplotGrob(World_map), # Add the world map xmin = -3, xmax = 3, # Specify the window the inset sits in ymin = 57.5, ymax = 60.5) 6.2 Backgrounds Similarly to stacking plots on top for an inset, you may want to put an image underneath your current plot. This can be a fast way of plotting something like a detailed map of the world behind your data, instead of asking R to calculate one itself and overworking your computer. The thing to remember here is to make sure the image has the same dimensions as the plot you’re making as the overlay. ICES &lt;- sf::st_read(&quot;./Data/ICES_areas/&quot;, quiet = TRUE) # Import the polygons from a shapefile ggplot() + # Start a plot ggpubr::background_image(png::readPNG(&quot;./_book/elevation.png&quot;)) + # Add the image of the world geom_sf(data = ICES, size = 0.5, colour = &quot;orange&quot;, fill = NA) + # Add the polygons theme_minimal() + # Use an appearance template labs(x = &quot;Longitude (E)&quot;, y = &quot;Latitude (N)&quot;, # Add some labels caption = &quot;ICES fishing areas&quot;, fill = NULL) + coord_sf(expand = FALSE, xlim = c(-180, 180), ylim = c(-90, 90)) # Ensure the plot size matches the image 6.3 3D It’s also recently become possible to render 3d maps in R using the rayshader package. I would class these as “pretty” maps which may be useful for presentations. The code is a bit more complicated, and can be demanding on your computer, but the results are cool! For examples and blogs you can look here "]]
